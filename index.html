<!DOCTYPE html>

<html>

<head>
    <title>Wallpaper</title>
    <link rel="stylesheet" href="styles.css">
    <!-- <script type="text/javascript" src="AudioScript.js"></script> -->
    <script type="module">

        // Code built with the help of https://tympanus.net/codrops/2019/09/24/crafting-stylised-mouse-trails-with-ogl/

        import {
            Polyline,
            Renderer,
            Transform,
            Geometry,
            Program,
            Mesh,
            Vec3,
            Vec2,
            Color
        } from "https://cdn.jsdelivr.net/npm/ogl@0.0.32/dist/ogl.mjs";

        const binGroup = 1 //Default at 1
        const numBins = Math.round(64 / binGroup); //The number of bins/buckets in the visualization
        const reverseLimit = 400; //ms between reverses
        const melFactor = 4;
        const bassFactor = 4;
        const totalFactor = 2;
        const melShrink = 0.69; //Rate the max recorded value shrinks
        const bassShrink = 0.69; //Nice
        const totalShrink = 0.69; //NICE

        const colors = ["#800801", "#FF584F", "#FF0E03", "#802C28", "#CC0C02"];
        const length = 16;

        let audio = [];
        const listener = arr => {
            audio = arr;
        };

        window.onload = function () {
            const vertex = `
        attribute vec3 position;
        attribute vec3 next;
        attribute vec3 prev;
        attribute vec2 uv;
        attribute float side;

        uniform vec2 uResolution;
        uniform float uDPR;
        uniform float uThickness;

        vec4 getPosition() {
            vec2 aspect = vec2(uResolution.x / uResolution.y, 1);
            vec2 nextScreen = next.xy * aspect;
            vec2 prevScreen = prev.xy * aspect;

            vec2 tangent = normalize(nextScreen - prevScreen);
            vec2 normal = vec2(-tangent.y, tangent.x);
            normal /= aspect;
            normal *= 1.0 - pow(abs(uv.y - 0.5) * 1.9, 2.0);

            float pixelWidth = 1.0 / (uResolution.y / uDPR);
            normal *= pixelWidth * uThickness;

            // When the points are on top of each other, shrink the line to avoid artifacts.
            float dist = length(nextScreen - prevScreen);
            normal *= smoothstep(0.0, 0.02, dist);

            vec4 current = vec4(position, 1);
            current.xy -= normal * side;
            return current;
        }

        void main() {
            gl_Position = getPosition();
        }
    `;

            {
                const renderer = new Renderer({
                    dpr: 2, transparent: true, alpha: true,
                    premultiplyAlpha: false
                });
                const gl = renderer.gl;
                document.getElementById("canvas").appendChild(gl.canvas);
                // gl.clearColor(0.9, 0.9, 0.9, 0.1);

                const scene = new Transform();

                function resize(lines) {
                    renderer.setSize(window.innerWidth, window.innerHeight);

                    // We call resize on the polylines to update their resolution uniforms
                    lines.forEach(line => line.polyline.resize());
                }
                window.addEventListener("resize", resize, false);

                // Just a helper function to make the code neater
                function random(a, b) {
                    const alpha = Math.random();
                    return a * (1.0 - alpha) + b * alpha;
                }

                // We're going to make a number of different coloured lines for fun.

                // Call initial resize after creating the polylines

                var melMax = 0;
                var bassMax = 0;
                var iMax = 8;
                var flip = true;
                var lastFlipped = Date.now();
                var intensity = 0;

                class Particle {
                    constructor(x, y, radian, colors) {
                        this.x = x;
                        this.y = y;
                        this.radius = window.innerHeight / 32;
                        this.arcRadius = window.innerHeight / 4;
                        this.radians = radian;
                        this.velocity = 0.05;
                        this.particle = new Vec3();
                        this.tmp = new Vec3();
                        this.lines = [];
                        this.colors = colors;

                        this.update = (iMax, intensity) => {
                            this.arcRadius = window.innerHeight / 256 + Math.round((7 * this.arcRadius + iMax * window.innerHeight / 128) / 8);
                            this.velocity = flip ? 0.01 + Math.sqrt(intensity) / 48 : -(0.01 + Math.sqrt(intensity) / 48);
                            this.radians += this.velocity;
                            this.x = x + this.arcRadius * Math.cos(this.radians);
                            this.y = y + this.arcRadius * Math.sin(this.radians);
                            this.particle.set(
                                (this.x / gl.renderer.width) * 2 - 1,
                                (this.y / gl.renderer.height) * -2 + 1,
                                0
                            );
                            this.draw();
                        };
                        this.draw = _ => {
                            this.lines.forEach(line => {
                                // Update polyline input points
                                for (let i = line.points.length - 1; i >= 0; i--) {
                                    if (!i) {
                                        // For the first point, spring ease it to the mouse position
                                        this.tmp
                                            .copy(this.particle)
                                            .add(line.currOffset)
                                            .sub(line.points[i])
                                            .multiply(line.spring);
                                        line.currVelocity.add(this.tmp).multiply(line.friction);
                                        line.points[i].add(line.currVelocity);
                                    } else {
                                        // The rest of the points ease to the point in front of them, making a line
                                        line.points[i].lerp(line.points[i - 1], 0.9);
                                    }
                                }
                                line.polyline.updateGeometry();
                            });
                        };

                        this.initLines = _ => {
                            this.colors.forEach(
                                (color, i) => {
                                    // Store a few values for each lines' randomised spring movement
                                    const line = {
                                        spring: random(0.02, 0.1),
                                        friction: random(0.7, 0.95),
                                        currVelocity: new Vec3(),
                                        currOffset: new Vec3(random(0, 1) * 0.005)
                                    };

                                    // Create an array of Vec3s (eg [[0, 0, 0], ...])
                                    const points = (line.points = []);
                                    for (let i = 0; i < length; i++) points.push(new Vec3());

                                    line.polyline = new Polyline(gl, {
                                        points,
                                        vertex,
                                        uniforms: {
                                            uColor: { value: new Color(color) },
                                            uThickness: { value: random(32, 64) }
                                        }
                                    });

                                    line.polyline.mesh.setParent(scene);

                                    this.lines.push(line);
                                }
                            );
                        }
                    }
                }

                //Init everything
                const particle1 = new Particle(window.innerWidth / 2, window.innerHeight / 2, Math.PI * 0.5, colors);
                const particle2 = new Particle(window.innerWidth / 2, window.innerHeight / 2, Math.PI * 1.5, colors);
                particle1.initLines();
                particle2.initLines();
                resize(particle1.lines)
                resize(particle2.lines)

                requestAnimationFrame(updateLines);
                function updateLines(t) {
                    requestAnimationFrame(updateLines);

                    getIMax();

                    if (melMax < 0.00000001 && intensity < 0.00000001) {
                        //If melMax and intensity is practically 0;
                        iMax = 0;
                    }

                    particle1.update(iMax, intensity);
                    particle2.update(iMax, intensity);
                    renderer.render({ scene });
                    // gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                }
            }
            window.wallpaperRegisterAudioListener(listener);

            const getIMax = _ => {
                var currIntensity = 0;
                var bassIntensity = 0;

                for (var i = 0; i < audio.length / 2; ++i) {

                    var currTotal = audio[i] + audio[i + audio.length / 2];
                    if (i >= numBins / 3 && currTotal >= melMax * melFactor) {
                        iMax = i;
                        melMax = currTotal;
                    } else if (i < numBins / 4) {
                        bassIntensity += currTotal;
                    }
                    currIntensity += currTotal;
                }
                if (this.Date.now() - lastFlipped >= reverseLimit
                    && bassIntensity > bassMax * 1.3
                    && bassIntensity > numBins / 32) {
                    if (currIntensity > intensity * totalFactor) {
                        flip = !flip;
                        lastFlipped = this.Date.now();
                        bassMax = bassIntensity;
                        intensity = currIntensity;
                    } else if (currIntensity >= intensity) {
                        intensity = currIntensity;
                    }
                } else if (bassIntensity >= bassMax && bassIntensity <= bassMax * 1.3) {
                    bassMax = bassIntensity;
                }

                melMax *= melShrink;
                bassMax *= bassShrink;
                if (currIntensity < intensity) {
                    intensity *= totalShrink;
                }
                iMax = Math.floor(iMax / binGroup);
            }
        }
    </script>
</head>

<body>
    <main id="canvas">
        <div id="overlay">
            <img id="center" src="assets/1024px-Yin_yang.svg.png" alt="">
        </div>
    </main>
</body>

</html>